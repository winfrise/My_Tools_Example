<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Canvas 多样式印章切换 (国风质感合集)</title>
  <style>
    canvas { 
      border: 1px solid #eee; 
      background: #fff; 
      margin: 20px 0;
    }
    /* 单行按钮组样式 */
    .seal-btn-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .seal-btn {
      padding: 6px 12px;
      border: 1px solid #d03020;
      background-color: #fff;
      color: #c02f23;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .seal-btn:hover {
      background-color: #fef0ef;
    }
    .seal-btn.active {
      background-color: #c02f23;
      color: #fff;
      border-color: #a0281c;
    }
  </style>
</head>
<body>
  <!-- 样式切换按钮组 -->
  <div class="seal-btn-group">
    <button class="seal-btn" data-style="flyWhite">飞白断墨印章</button>
    <button class="seal-btn" data-style="carve">篆刻拓印印章</button>
    <button class="seal-btn" data-style="simpleSoft">极简柔边印章</button>
    <button class="seal-btn" data-style="inkSpread">印泥晕染印章</button>
    <button class="seal-btn active" data-style="oldBroken">做旧残边印章</button>
    <button class="seal-btn" data-style="doubleLine">双线回纹印章</button>
  </div>

  <canvas id="canvas" width="400" height="400"></canvas>

  <script>
    // 全局变量
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const centerX = 200, centerY = 200;
    const density = 0.012; // 通用步长
    let currentStyle = 'oldBroken'; // 默认样式

    // 各样式配置参数
    const styleConfig = {
      // 版本一：飞白断墨印章
      flyWhite: {
        radius: 150,
        lineWidth: 8,
        roughness: 1.5,
        sealColor: '#c02f23',
        drawPath: drawFlyWhitePath,
        drawStyle: drawBasicStyle,
        texture: createUltraDelicateTexture,
        composite: 'soft-light',
        alpha: 0.8
      },
      // 版本二：篆刻拓印印章
      carve: {
        radius: 150,
        lineWidth: 8,
        roughness: 1.4,
        sealColor: '#b52c20',
        drawPath: drawBasicPath,
        drawStyle: drawBasicStyle,
        texture: createCarveTexture,
        composite: 'multiply',
        alpha: 0.75
      },
      // 版本三：极简柔边印章
      simpleSoft: {
        radius: 150,
        lineWidth: 8,
        roughness: 1.0,
        sealColor: '#c12f22',
        drawPath: drawBasicPath,
        drawStyle: drawBasicStyle,
        texture: createSmoothTexture,
        composite: 'soft-light',
        alpha: 0.65,
        density: 0.01 // 专属超密步长
      },
      // 版本四：印泥晕染印章
      inkSpread: {
        radius: 150,
        lineWidth: 9,
        roughness: 1.2,
        sealColor: '#bc2d21',
        drawPath: drawBasicPath,
        drawStyle: drawGradientStyle,
        texture: createInkTexture,
        composite: 'soft-light',
        alpha: 0.7
      },
      // 版本五：做旧残边印章
      oldBroken: {
        radius: 150,
        lineWidth: 8,
        roughness: 1.5,
        sealColor: '#a8291e',
        drawPath: drawBrokenPath,
        drawStyle: drawBasicStyle,
        texture: createOldTexture,
        composite: 'overlay',
        alpha: 0.7
      },
      // 版本六：双线回纹印章
      doubleLine: {
        outRadius: 150,
        inRadius: 138,
        lineWidth: 8,
        roughness: 1.3,
        sealColor: '#c02f23',
        drawPath: drawDoubleLinePath,
        drawStyle: drawBasicStyle,
        texture: createUltraDelicateTexture,
        composite: 'soft-light',
        alpha: 0.75
      }
    };

    // ========== 路径绘制函数 ==========
    // 基础毛边路径（极简/拓印/晕染通用）
    function drawBasicPath(config) {
      ctx.beginPath();
      const step = config.density || density;
      for (let angle = 0; angle < Math.PI * 2; angle += step) {
        const randomOffset = (Math.random() - 0.5) * config.roughness * 0.8;
        const r = config.radius + randomOffset;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        angle === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
    }


    // 飞白断墨路径
    function drawFlyWhitePath(config) {
      ctx.beginPath();
      let drawFlag = true;
      for (let angle = 0; angle < Math.PI * 2; angle += density) {
        // 三层微偏移
        const softOffset = (Math.random() - 0.5) * config.roughness * 0.9;
        const tinyJitter = Math.random() * config.roughness * 0.4 - (config.roughness * 0.2);
        const flyEdge = Math.random() > 0.96 ? (Math.random() - 0.5) * config.roughness : 0;
        const randomOffset = softOffset + tinyJitter + flyEdge;
        const r = config.radius + randomOffset;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;

        // 飞白断墨逻辑
        const randomBreak = Math.random();
        if (randomBreak > 0.985) drawFlag = !drawFlag;
        if (drawFlag) {
          angle === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        } else {
          ctx.moveTo(x, y);
        }
      }
      ctx.closePath();
    }

    // 做旧残边路径
    function drawBrokenPath(config) {
      ctx.beginPath();
      for (let angle = 0; angle < Math.PI * 2; angle += density) {
        const randomOffset = (Math.random() - 0.5) * config.roughness * 0.9;
        const brokenOffset = Math.random() > 0.99 ? (Math.random() - 0.5) * config.roughness * 3 : 0;
        const r = config.radius + randomOffset + brokenOffset;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        angle === 0 ? (ctx.moveTo(x, y)) : ctx.lineTo(x, y);
      }
      ctx.closePath();
    }

    // 双线回纹路径
    function drawDoubleLinePath(config) {
      // 外环路径
      ctx.beginPath();
      for (let angle = 0; angle < Math.PI * 2; angle += density) {
        const randomOffset = (Math.random() - 0.5) * config.roughness * 0.8;
        const r = config.outRadius + randomOffset;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        angle === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();

      // 内环路径
      ctx.beginPath();
      for (let angle = 0; angle < Math.PI * 2; angle += density) {
        const randomOffset = (Math.random() - 0.5) * config.roughness * 0.8;
        const r = config.inRadius + randomOffset;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        angle === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
    }

    // ========== 样式绘制函数 ==========
    // 基础实色样式
    function drawBasicStyle(config) {
      ctx.lineWidth = config.lineWidth;
      ctx.strokeStyle = config.sealColor;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
    }

    // 晕染渐变样式
    function drawGradientStyle(config) {
      const gradient = ctx.createRadialGradient(
        centerX, centerY, config.radius - 2,
        centerX, centerY, config.radius + 2
      );
      gradient.addColorStop(0, config.sealColor);
      gradient.addColorStop(1, `rgba(${parseInt(config.sealColor.slice(1,3),16)},${parseInt(config.sealColor.slice(3,5),16)},${parseInt(config.sealColor.slice(5,7),16)},0.6)`);
      ctx.lineWidth = config.lineWidth;
      ctx.strokeStyle = gradient;
      ctx.lineCap = 'round';
      ctx.stroke();
    }

    // ========== 纹理生成函数 ==========
    // 超细纹理（飞白/双线通用）
    function createUltraDelicateTexture(config) {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 12; texCanvas.height = 12;
      const texCtx = texCanvas.getContext('2d');
      texCtx.fillStyle = 'rgba(0,0,0,0)'; texCtx.fillRect(0, 0, 12, 12);
      for (let i = 0; i < 35; i++) {
        const x = Math.random() * 12, y = Math.random() * 12;
        texCtx.fillStyle = Math.random() > 0.75 ? '#a21f16' : config.sealColor;
        texCtx.fillRect(x, y, Math.random() * 0.8 + 0.1, Math.random() * 0.8 + 0.1);
      }
      return ctx.createPattern(texCanvas, 'repeat');
    }

    // 篆刻拓印纹理
    function createCarveTexture(config) {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 10; texCanvas.height = 10;
      const texCtx = texCanvas.getContext('2d');
      texCtx.fillStyle = 'rgba(0,0,0,0)'; texCtx.fillRect(0, 0, 10, 10);
      // 磨砂细颗粒
      for (let i = 0; i < 40; i++) {
        const x = Math.random() * 10, y = Math.random() * 10;
        const size = Math.random() * 0.7 + 0.1;
        texCtx.fillStyle = Math.random() > 0.7 ? '#881c14' : config.sealColor;
        texCtx.fillRect(x, y, size, size);
      }
      // 石纹细纹
      for (let i = 0; i < 10; i++) {
        const x = Math.random() * 10, y = Math.random() * 10;
        texCtx.fillStyle = '#992016';
        texCtx.fillRect(x, y, 0.2, Math.random() * 3);
      }
      return ctx.createPattern(texCanvas, 'repeat');
    }

    // 极简柔化纹理
    function createSmoothTexture(config) {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 15; texCanvas.height = 15;
      const texCtx = texCanvas.getContext('2d');
      texCtx.fillStyle = 'rgba(0,0,0,0)'; texCtx.fillRect(0, 0, 15, 15);
      for (let i = 0; i < 25; i++) {
        const x = Math.random() * 15, y = Math.random() * 15;
        texCtx.fillStyle = config.sealColor;
        texCtx.fillRect(x, y, 0.5, 0.5);
      }
      return ctx.createPattern(texCanvas, 'repeat');
    }

    // 水墨晕染纹理
    function createInkTexture(config) {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 14; texCanvas.height = 14;
      const texCtx = texCanvas.getContext('2d');
      texCtx.fillStyle = 'rgba(0,0,0,0)'; texCtx.fillRect(0, 0, 14, 14);
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * 14, y = Math.random() * 14;
        const size = Math.random() * 1 + 0.1;
        texCtx.fillStyle = Math.random() > 0.7 ? '#9d2419' : config.sealColor;
        texCtx.fillRect(x, y, size, size);
      }
      return ctx.createPattern(texCanvas, 'repeat');
    }

    // 做旧纹理
    function createOldTexture(config) {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 12; texCanvas.height = 12;
      const texCtx = texCanvas.getContext('2d');
      texCtx.fillStyle = 'rgba(0,0,0,0)'; texCtx.fillRect(0, 0, 12, 12);
      // 做旧浅斑
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * 12, y = Math.random() * 12;
        texCtx.fillStyle = Math.random() > 0.7 ? '#7c1f17' : config.sealColor;
        texCtx.fillRect(x, y, 1, 1);
      }
      return ctx.createPattern(texCanvas, 'repeat');
    }

    // ========== 核心渲染函数 ==========
    function renderSeal(styleName) {
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 获取当前样式配置
      const config = styleConfig[styleName];
      if (!config) return;

      // 绘制路径
      config.drawPath(config);
      
      // 绘制基础样式
      config.drawStyle(config);
      
      // 叠加纹理
      ctx.globalCompositeOperation = config.composite;
      ctx.globalAlpha = config.alpha;
      ctx.strokeStyle = config.texture(config);
      ctx.stroke();
      
      // 重置画布状态
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // ========== 事件绑定 ==========
    // 按钮切换事件
    document.querySelectorAll('.seal-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        // 移除所有激活状态
        document.querySelectorAll('.seal-btn').forEach(b => b.classList.remove('active'));
        // 添加当前激活状态
        this.classList.add('active');
        // 更新当前样式并重新渲染
        currentStyle = this.dataset.style;
        renderSeal(currentStyle);
      });
    });

    // 初始化渲染
    renderSeal(currentStyle);
  </script>
</body>
</html>