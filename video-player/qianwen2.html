<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>è§†é¢‘æ’­æ”¾å™¨ - æ”¯æŒæ­£æ–¹å½¢/é•¿æ–¹å½¢/åœ†å½¢è’™ç‰ˆ</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0; padding: 20px; background: #f5f5f5;
    }
    .player-wrapper { max-width: 960px; margin: 0 auto; }
    .player-fullscreen-target {
      position: relative; border: 1px solid #ccc; background: #000;
      --controls-height: 70px;
    }
    .video-container {
      position: relative; width: 100%; height: 500px; overflow: hidden; background: #000;
    }
    #video {
      width: 100%; height: 100%; object-fit: contain;
      transform-origin: center center;
    }
    #maskCanvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
      display: none; /* é»˜è®¤éšè— */
    }
    .custom-controls {
      position: relative; background: rgba(0,0,0,0.85); color: white; padding: 8px 12px;
    }
    .progress-row {
      width: 100%; height: 6px; background: #444; border-radius: 3px; cursor: pointer; margin-bottom: 8px;
    }
    .progress-bar { height: 100%; background: #1e90ff; border-radius: 3px; width: 0%; transition: width 0.1s; }
    .controls-row { display: flex; justify-content: space-between; align-items: center; }
    .control-btn {
      background: none; border: 1px solid #666; color: white; padding: 4px 10px; border-radius: 4px;
      cursor: pointer; font-size: 14px; min-width: 36px; text-align: center;
    }
    .control-btn:hover { background: rgba(255,255,255,0.1); border-color: #999; }
    .status-group { display: flex; align-items: center; gap: 12px; }
    .time-display { font-size: 13px; white-space: nowrap; }
    .volume-control { display: flex; align-items: center; gap: 6px; }
    .volume-slider { width: 60px; height: 4px; background: #444; border-radius: 2px; cursor: pointer; position: relative; }
    .volume-level { height: 100%; background: white; border-radius: 2px; width: 80%; }
    select {
      background: rgba(255,255,255,0.1); color: white; border: 1px solid #666;
      border-radius: 3px; padding: 2px 6px; font-size: 12px; cursor: pointer;
    }
    .player-fullscreen-target.fullscreen {
      position: fixed !important; top: 0 !important; left: 0 !important;
      width: 100vw !important; height: 100vh !important; z-index: 2000; background: #000;
    }
    .player-fullscreen-target.fullscreen .video-container {
      height: calc(100vh - var(--controls-height)) !important;
    }
    .top-controls {
      display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; align-items: center;
    }
    button { padding: 6px 12px; cursor: pointer; }
    input[type="text"] { flex: 1; min-width: 200px; padding: 6px; }
    .hint {
      font-size: 12px; color: #666; margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="player-wrapper">
    <h2>è§†é¢‘æ’­æ”¾å™¨ - æ”¯æŒæ­£æ–¹å½¢ / é•¿æ–¹å½¢ / åœ†å½¢è’™ç‰ˆ</h2>

    <div class="player-fullscreen-target" id="fullscreenTarget">
      <div class="video-container" id="container">
        <video id="video"></video>
        <canvas id="maskCanvas"></canvas>
      </div>

      <div class="custom-controls">
        <div class="progress-row" id="progressContainer">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="controls-row">
          <div class="playback-controls">
            <button class="control-btn" id="toStart">Â«Â«</button>
            <button class="control-btn" id="rewind">Â«</button>
            <button class="control-btn" id="playPause">â–¶</button>
            <button class="control-btn" id="forward">Â»</button>
            <button class="control-btn" id="toEnd">Â»Â»</button>
          </div>
          <div class="status-group">
            <span class="time-display" id="timeDisplay">00:00 / 00:00</span>
            <div class="volume-control">
              <span>ğŸ”ˆ</span>
              <div class="volume-slider" id="volumeSlider">
                <div class="volume-level" id="volumeLevel"></div>
              </div>
            </div>
            <select class="speed-select" id="speedSelect">
              <option value="0.5">0.5x</option>
              <option value="0.75">0.75x</option>
              <option value="1" selected>1x</option>
              <option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option>
              <option value="2">2x</option>
            </select>
            <button class="control-btn" id="fullscreenBtn">å…¨å±</button>
          </div>
        </div>
      </div>
    </div>

    <div class="top-controls">
      <input type="text" id="urlInput" placeholder="è¾“å…¥è§†é¢‘åœ°å€ï¼ˆæ”¯æŒ .m3u8 æˆ– .mp4ï¼‰"
             value="https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8" />
      <button id="loadBtn">åŠ è½½è§†é¢‘</button>
      <button id="zoomIn">+</button>
      <button id="zoomOut">âˆ’</button>
      <span id="zoomLevel">100%</span>
      <button id="resetView">é‡ç½®è§†å›¾</button>

      <!-- è’™ç‰ˆæ§åˆ¶ -->
      <button id="toggleMaskMode">å¼€å¯è’™ç‰ˆç»˜åˆ¶</button>
      <select id="maskShapeSelect">
        <option value="rect">é•¿æ–¹å½¢</option>
        <option value="square">æ­£æ–¹å½¢</option>
        <option value="circle">åœ†å½¢</option>
      </select>
      <label>
        é®ç½©é¢œè‰²:
        <input type="color" id="maskColor" value="#000000" />
      </label>
      <label>
        é€æ˜åº¦:
        <input type="range" id="maskOpacity" min="0" max="1" step="0.01" value="0.7" />
      </label>
      <button id="clearMasks">æ¸…ç©ºæ‰€æœ‰è’™ç‰ˆ</button>
    </div>
    <p class="hint">
      æ“ä½œæç¤ºï¼š<br>
      â€¢ å¼€å¯â€œè’™ç‰ˆç»˜åˆ¶â€åï¼Œåœ¨è§†é¢‘åŒºåŸŸæ‹–åŠ¨åˆ›å»ºè’™ç‰ˆ<br>
      â€¢ å·²æœ‰è’™ç‰ˆï¼šå·¦é”®æ‹–åŠ¨ç§»åŠ¨ï¼Œå³é”®ç‚¹å‡»åˆ é™¤<br>
      â€¢ å…³é—­è’™ç‰ˆæ¨¡å¼åï¼Œé®ç½©è‡ªåŠ¨éšè—ï¼Œè§†é¢‘æ­£å¸¸æ’­æ”¾
    </p>
  </div>

  <script>
    // ========== DOM ==========
    const video = document.getElementById('video');
    const container = document.getElementById('container');
    const maskCanvas = document.getElementById('maskCanvas');
    const maskCtx = maskCanvas.getContext('2d');

    // æ§ä»¶
    const urlInput = document.getElementById('urlInput');
    const loadBtn = document.getElementById('loadBtn');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const resetBtn = document.getElementById('resetView');
    const zoomLevelEl = document.getElementById('zoomLevel');
    const playPauseBtn = document.getElementById('playPause');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const timeDisplay = document.getElementById('timeDisplay');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeLevel = document.getElementById('volumeLevel');
    const speedSelect = document.getElementById('speedSelect');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const toggleMaskModeBtn = document.getElementById('toggleMaskMode');
    const maskShapeSelect = document.getElementById('maskShapeSelect');
    const maskColorInput = document.getElementById('maskColor');
    const maskOpacityInput = document.getElementById('maskOpacity');
    const clearMasksBtn = document.getElementById('clearMasks');

    // ========== çŠ¶æ€ ==========
    let scale = 1, translateX = 0, translateY = 0;
    const minScale = 0.1, maxScale = 10;

    let isPanning = false;
    let startPanX = 0, startPanY = 0;

    let isMaskMode = false;
    let masks = []; // { x, y, w, h, shape: 'rect' | 'square' | 'circle' }
    let drawingMask = null;
    let draggingMaskIndex = -1;

    // ========== å·¥å…·å‡½æ•° ==========
    function formatTime(seconds) {
      if (isNaN(seconds)) return '00:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTransform() {
      video.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
      zoomLevelEl.textContent = `${Math.round(scale * 100)}%`;
    }

    function resetView() {
      scale = 1; translateX = 0; translateY = 0;
      updateTransform();
    }

    function loadVideo(src) {
      resetView();
      if (Hls.isSupported() && src.endsWith('.m3u8')) {
        if (video.hls) video.hls.destroy();
        const hls = new Hls();
        video.hls = hls;
        hls.loadSource(src);
        hls.attachMedia(video);
      } else {
        video.src = src;
      }
    }

    // ========== è’™ç‰ˆæ¸²æŸ“ ==========
    function renderMask() {
      if (!isMaskMode) {
        maskCanvas.style.display = 'none';
        return;
      }

      maskCanvas.style.display = 'block';
      const rect = container.getBoundingClientRect();
      maskCanvas.width = rect.width;
      maskCanvas.height = rect.height;

      const ctx = maskCtx;
      ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

      // å¡«å……é®ç½©èƒŒæ™¯
      const opacity = parseFloat(maskOpacityInput.value);
      const color = maskColorInput.value;
      ctx.fillStyle = color + Math.round(opacity * 255).toString(16).padStart(2, '0');
      ctx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

      // æŒ–æ‰è’™ç‰ˆåŒºåŸŸ
      ctx.globalCompositeOperation = 'destination-out';

      [...masks, drawingMask].forEach(mask => {
        if (!mask) return;
        drawMask(ctx, mask);
      });

      ctx.globalCompositeOperation = 'source-over';
    }

    function drawMask(ctx, mask) {
      const { x, y, w, h, shape } = mask;
      if (shape === 'circle') {
        const r = Math.min(w, h) / 2;
        const cx = x + w / 2;
        const cy = y + h / 2;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
      } else if (shape === 'square') {
        // å¼ºåˆ¶ä¸ºæ­£æ–¹å½¢ï¼šå–å®½é«˜ä¸­è¾ƒå°å€¼
        const size = Math.min(Math.abs(w), Math.abs(h));
        const actualW = w >= 0 ? size : -size;
        const actualH = h >= 0 ? size : -size;
        const drawX = w >= 0 ? x : x + actualW;
        const drawY = h >= 0 ? y : y + actualH;
        ctx.fillRect(drawX, drawY, Math.abs(actualW), Math.abs(actualH));
      } else {
        // 'rect' â€”â€” æ™®é€šçŸ©å½¢
        ctx.fillRect(x, y, w, h);
      }
    }

    function clearMasks() {
      masks = [];
      renderMask();
    }

    function isPointInMask(px, py, mask) {
      const { x, y, w, h, shape } = mask;
      if (shape === 'circle') {
        const r = Math.min(Math.abs(w), Math.abs(h)) / 2;
        const cx = x + w / 2;
        const cy = y + h / 2;
        return Math.hypot(px - cx, py - cy) <= r;
      } else if (shape === 'square') {
        const size = Math.min(Math.abs(w), Math.abs(h));
        const left = w >= 0 ? x : x + w;
        const top = h >= 0 ? y : y + h;
        const right = left + size;
        const bottom = top + size;
        return px >= left && px <= right && py >= top && py <= bottom;
      } else {
        const left = Math.min(x, x + w);
        const right = Math.max(x, x + w);
        const top = Math.min(y, y + h);
        const bottom = Math.max(y, y + h);
        return px >= left && px <= right && py >= top && py <= bottom;
      }
    }

    // ========== äº‹ä»¶ç»‘å®š ==========
    // ç¼©æ”¾ä¸å¹³ç§»
    zoomInBtn.addEventListener('click', () => {
      scale = Math.min(maxScale, scale + 0.2);
      updateTransform();
    });
    zoomOutBtn.addEventListener('click', () => {
      scale = Math.max(minScale, scale - 0.2);
      updateTransform();
    });
    resetBtn.addEventListener('click', resetView);

    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      scale = Math.min(maxScale, Math.max(minScale, scale + delta));
      updateTransform();
    }, { passive: false });

    // ä¸»è¦äº¤äº’
    container.addEventListener('mousedown', (e) => {
      const rect = container.getBoundingClientRect();
      const localX = e.clientX - rect.left;
      const localY = e.clientY - rect.top;

      if (isMaskMode) {
        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åˆ°å·²æœ‰è’™ç‰ˆ
        let clickedMaskIndex = -1;
        for (let i = masks.length - 1; i >= 0; i--) {
          if (isPointInMask(localX, localY, masks[i])) {
            clickedMaskIndex = i;
            break;
          }
        }

        if (clickedMaskIndex >= 0) {
          if (e.button === 2) { // å³é”®åˆ é™¤
            e.preventDefault();
            masks.splice(clickedMaskIndex, 1);
            renderMask();
            return;
          } else if (e.button === 0) { // å·¦é”®æ‹–åŠ¨
            draggingMaskIndex = clickedMaskIndex;
            const mask = masks[draggingMaskIndex];
            startPanX = localX - mask.x;
            startPanY = localY - mask.y;
            container.style.cursor = 'grabbing';
            e.preventDefault();
            return;
          }
        }

        // å¼€å§‹ç»˜åˆ¶æ–°è’™ç‰ˆ
        drawingMask = {
          startX: localX,
          startY: localY,
          x: localX,
          y: localY,
          w: 0,
          h: 0,
          shape: maskShapeSelect.value
        };
        e.preventDefault();
        return;
      }

      // éè’™ç‰ˆæ¨¡å¼ï¼šå¹³ç§»
      isPanning = true;
      startPanX = e.clientX - translateX;
      startPanY = e.clientY - translateY;
      container.style.cursor = 'grabbing';
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      const localX = e.clientX - rect.left;
      const localY = e.clientY - rect.top;

      if (draggingMaskIndex >= 0) {
        const mask = masks[draggingMaskIndex];
        mask.x = localX - startPanX;
        mask.y = localY - startPanY;
        renderMask();
        return;
      }

      if (drawingMask) {
        const dx = localX - drawingMask.startX;
        const dy = localY - drawingMask.startY;
        drawingMask.w = dx;
        drawingMask.h = dy;
        drawingMask.x = dx >= 0 ? drawingMask.startX : localX;
        drawingMask.y = dy >= 0 ? drawingMask.startY : localY;
        renderMask();
        return;
      }

      if (isPanning) {
        translateX = e.clientX - startPanX;
        translateY = e.clientY - startPanY;
        updateTransform();
        return;
      }
    });

    window.addEventListener('mouseup', () => {
      if (drawingMask) {
        const { w, h } = drawingMask;
        if (Math.abs(w) > 5 && Math.abs(h) > 5) {
          masks.push({
            x: drawingMask.x,
            y: drawingMask.y,
            w: Math.abs(w),
            h: Math.abs(h),
            shape: drawingMask.shape
          });
        }
        drawingMask = null;
        renderMask();
        return;
      }

      if (draggingMaskIndex >= 0) {
        draggingMaskIndex = -1;
        container.style.cursor = 'crosshair';
        return;
      }

      if (isPanning) {
        isPanning = false;
        container.style.cursor = isMaskMode ? 'crosshair' : 'move';
      }
    });

    // ç¦ç”¨å³é”®èœå•
    container.addEventListener('contextmenu', (e) => {
      if (isMaskMode) e.preventDefault();
    });

    // è’™ç‰ˆæ§åˆ¶
    toggleMaskModeBtn.addEventListener('click', () => {
      isMaskMode = !isMaskMode;
      toggleMaskModeBtn.textContent = isMaskMode ? 'å…³é—­è’™ç‰ˆç»˜åˆ¶' : 'å¼€å¯è’™ç‰ˆç»˜åˆ¶';
      container.style.cursor = isMaskMode ? 'crosshair' : 'move';
      renderMask();
    });

    clearMasksBtn.addEventListener('click', clearMasks);
    [maskColorInput, maskOpacityInput].forEach(el => {
      el.addEventListener('input', renderMask);
    });

    // ========== è§†é¢‘æ§åˆ¶ ==========
    video.addEventListener('loadedmetadata', () => {
      timeDisplay.textContent = `00:00 / ${formatTime(video.duration)}`;
    });
    video.addEventListener('timeupdate', () => {
      const percent = (video.currentTime / (video.duration || 1)) * 100;
      progressBar.style.width = `${percent}%`;
      timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
    });
    playPauseBtn.addEventListener('click', () => {
      if (video.paused) { video.play(); playPauseBtn.textContent = 'â¸'; }
      else { video.pause(); playPauseBtn.textContent = 'â–¶'; }
    });
    progressContainer.addEventListener('click', (e) => {
      const rect = progressContainer.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const ratio = Math.max(0, Math.min(1, clickX / rect.width));
      video.currentTime = ratio * (video.duration || 0);
    });
    volumeSlider.addEventListener('click', (e) => {
      const rect = volumeSlider.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      let vol = Math.max(0, Math.min(1, clickX / rect.width));
      video.volume = vol;
      volumeLevel.style.width = `${vol * 100}%`;
    });
    speedSelect.addEventListener('change', () => {
      video.playbackRate = parseFloat(speedSelect.value);
    });

    // å…¨å±
    function toggleFullscreen() {
      if (!document.fullscreenElement) fullscreenTarget.requestFullscreen();
      else document.exitFullscreen();
    }
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    document.addEventListener('fullscreenchange', () => {
      fullscreenBtn.textContent = document.fullscreenElement ? 'é€€å‡ºå…¨å±' : 'å…¨å±';
      setTimeout(renderMask, 100);
    });

    // åˆå§‹åŒ–
    loadBtn.addEventListener('click', () => loadVideo(urlInput.value.trim()));
    window.addEventListener('load', () => loadVideo(urlInput.value.trim()));
    window.addEventListener('resize', renderMask);
  </script>
</body>
</html>